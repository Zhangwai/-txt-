第一周：
本周完成的工作
1、熟悉公司、安装环境
2、学习前端编码规范、熟悉git流程
3、回顾熟悉vue配置、语法、插件并且发布3篇学习博客
4、拉取熟悉官网项目代码
5、优化官网代码
6、初步学习vite的简单使用、配置
下周工作安排
1、继续思考优化官网的代码、结构
2、 进阶学习ts的使用
3、继续熟悉ant-design-vue
4、继续熟悉vite的配置

实习期遇到的一些问题以及思考：
1、查看官网项目代码的时候发现每一张图片的请求地址都写死在每一个img标签的src里面，
所有的url都这样写 ‘公司阿里云地址’+‘资源所在位置路径’，这样的话我们可以把公共
的阿里云地址单独拿出来写在vue的环境变量里面，然后去做拼接，这样的话以后只要在环境
变量里面改一下就可以全局替换了。
2、项目代码html标签重复写的地方有很多，我们可以找到共性然后用通过数据的遍历去生成，
这样子就可以减少代码量，看起来更加清爽
3、请求接口遇到不同的前缀有的用'/api'，有的用'/xxx',等多个不同地址的时候（一个vue项目中配置请求多个服务端解决方案），
怎么去解决这样的问题？
初步思考：通过修改axios发起请求的时候去设置baseURL加上前缀试图解决问题，发现使用
的axios是一个实例，当每次传参改变时，其他地方使用到的axios的baseURL也会改变，不符
合我们的要求。
解决方案：
1、单独封装一个颗粒度更加细的request类，导出多个类的实例，每个实例都有自己不同的baseURL，每次创建这个request
实例的时候这个类里面使用不同的config去创建axios的实例，config由new request（config）通过形参的方式
传入，这样做的好处，可以拓展axios的config，添加自己要使用的属性，拦截器的颗粒度可以做到很
小，如果请求的库不更新了，只需要在这个类里面替换新的请求库就能让全局的请求可以用，不用
到每个页面一个一个的改。
2、先把axios中baseURL设置为空，再通过webpack代理pathRewrite改变他的路经。
	
第二周：
本周完成的工作：
1、完成官网不改动部分代码优化，优化项目案例页面、项目案例细节部分、最近动态、关于我们、加入我们、联系我们等页面
2、学习了vue的自定义指令，写了图片懒加载的demo
3、学习了进阶的TS提供几种内置的预定义的条件类型
4、了解了vue3的新的代理方式proxy，练习了其13种捕获器
下周目标：
1、根据iu图画官网，争取完成总进度50%
2、学习npm、yarn、cnpm包管理工具以及其原理
实习期遇到的一些问题以及思考：
1、因为交流的问题，把错误的代码拉下来了，在上面完成了优化后才发现这个代码是一个月前的老代码，哭了，尝试了和合并，
但是因为冲突问题具体也不清楚改保留哪些，就放弃了这个操作，选择了蠢的办法，重新拉了一边代码重新新建了一条分支，然后
在一点点复制粘贴过去，虽然浪费了点时间，但是这样子最保险，总算没遇到啥别的问题，总算解决了。
2、第二就是Vue里面解决懒加载图片的问题，当时想到两个解决方案：
    一、就是使用vue自定义实现 
    二、使用vue的mixin混入
 我选择了第一种方案，然后利用IntersectionObserver这个api，异步监听dom在视口中的出现情况。
 为什么选择IntersectionObserver？
 在我们需要监听目标元素是否进入视口时，需要监听scroll事件，大量的计算会造成性能问题。
 IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。 即只有线程空闲下来，
 才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。

第三周：
本周完成的工作
1、完成官网代码优化前期工作
2、完成崇寿众治宝的demo
3、回顾熟悉vue2、element-ui、vuex等全家桶
下周工作安排
1、继续思考优化官网的代码、结构
实习期遇到的一些问题以及思考：
1、在写vue2项目的时候遇到操作响应式数组、对象的时候，比如说不用他重写的方法操作，极大的情况会出现数据更新
试图不更新的情况，在做项目的时候虽然知道这个原理，但是还是会犯糊涂，顺手就写下了bug，等到发现出问题的时候
去排查就会浪费很长的时间，所以在以后写vue2项目的时候，遇到操作响应式数组的时候一定要暗示自己，这个地方要多
加注意。其次还有css样式上面的一些心得，作为前端，但是真的没怎么重视写css，css真的挺难把他写的很好，写出来了，
但是不一定写的就是完美的，特别是在改组件里面的样式的时候，会发现它们的css设计的非常巧妙，利用css解析器,把css
当作js来写，一个模块一个模块、把css当作一个对象来写，很多地方非常值得我学习。
2、其次就是公司代码规范上的问题，每次提交代码锦怀帮我cr的时候都会找出一堆代码规范上面、多余的代码、以及自己没动脑子写下
的代码等等一堆问题，这一块真的要避免，看别人代码本就是一件需要耐心的事情，记得周四锦怀凌晨给我发了消息，都是关于我代码
质量上的问题。挺不好意思的，以后上交代码之前一定自己好好的过一遍，同时真的很感谢锦怀。
3、来到公司学到最多的还有git上面的一些操作，以前就只会基础的几个命令，没有尝试过合并commit、创建远程分支、将远程主分支合并到本地当前分支
等等，这一块一定要重新细致的在研究学习一下。
第四周
本周完成的工作
1、学习小程序的语法、结构等
2、熟悉小程序组件库的代码
3、根据小程序组件库文档运用了一遍组件的使用
4、根据使用情况列了一些错误需要改进以及需要进一步更近的地方
下周的安排
1、根据上周列出来的问题进行修复
2、尝试写未完成的组件
心得：
   这周大部分时间都在熟悉小程序开发,微信小程序开发，入门算是非常简单，只要看官文文档即可小程序简易教程。
如何申请小程序账号，如何开发自己第一个小程序，如何发布，这一系列hello world操作官方文档都有手把手教学。
小程序开发的每个步骤，提供的能力文档里都有，个人觉得，做小程序开发，有事没事都看下文档，因为小程序更
新比较快速，同时一些细小的能力我们可能会漏掉，所以多看文档。
   之后就是熟悉组件库的写法，了解他是怎么进行父子通信，定义关系等，在看我们自己的组件库的同时也参考了好多
其他的组件库，linui、wexui他们的写法和我们的很类似，结合在一起看，完全可以把他们的可取的地方拿过来，不好的
地方删除掉，来精进我们自己组件库，让我们的组件库更加健壮。
   另外刷到一个有意思的算法模板，二分查找应该算是比较简单好理解的算法，但是他的边界情况老是容易写错，不是那么
好想，好写。这次刷到一个红蓝边界模型可以帮助我们快速理解这个算法，让边界情况更加好理解。
模板如下：
l = -1 ,r = N
while l+1 != r
   m = Math.floor(r+l)/2
   if(isLeft)
      l = m
   else
      r= m
return l or r
附上链接：https://www.bilibili.com/video/BV1d54y1q7k7（有兴趣的可以看看）

第五周
本周完成的工作
1、完成小程序swiper组件
2、了解学习git merge和git rebase的区别 
3、熟悉git可视化工具 gitkraken
4、学习服务器自动化部署
5、调研小程序日期选择器的实现
6、修复小程序的组件库bug
下周的安排
1、争取做一版日期选择器
2、继续学习服务器的自动化部署

心得：
   小程序搭建组件还是挺复杂的，不像平时自己写项目的组件那般，只要根据项目的要求实现就可以了，
要考虑到的东西还是挺多的，要对小程序的通信理解好，父传子，子传父，兄弟组件通信，全局通信，小程序
不像vue和react的生态那么好，全局通信，组件通信还是要靠自己去写一个发布订阅的evnetbus，还有公司的
代码规范，这周也深刻的领教到了，写一版代码因为代码规范被打回来无数次，虽然在当时还听不想改的，但是
后面改完和进去了，回过头想一想，我感觉自己还挺有成就感的，我觉得这对我来说后续的日子，在代码规范上面，
代码可读性上更加有帮助，还有自己之前写的代码都很少用es6的语法，代码看起来就不是很简洁，虽然知道很多es6
的语法，但是一到写的是时候就是不用，以后要多去刻意的训练，多去用。
   这周特别了解了一下自动部署服务器的这块内容，之前只知道打包后手动部署服务器，但是随着技术的发展，
部署的过程中所有的操作全部自动化，无需人工手工干预。相比传统手动部署，比如你你项目新增加一个功能，
你就得把 本地更新 --- 构建 --- 发布 这一套流程走一遍，看似没有什么难的，但是一旦项目多，部署频繁，
这种就效率低下，还会存在人为的误操作性，所以自动化部署他就来了~我学习的是jenkins，在服务器里面安装一个
jenkins，然后绑定一下我们的git的远程仓库，然后跑一个任务，比如说每半个小时去拉一下git仓库的代码，然后自动
去部署，大致的流程就是这样子。
最后送上一句话：（有关学习方面上的）
或许一个人可以走的很快，但三两个人可以走的很远。

第六周
本周完成
1、熟悉擅自分后台管理代码
2、完成善自分违纪管理模块
3、完成组件库datepicker一个功能的demo
4、修复部分违纪模块bug
下周安排：
1、修复违纪模块bug
2、继续开发小程序组件库
心得：
   这周在前端开发上面遇到了许多知识盲区，比如说需求中有多个倒计时在同一个页面的需求，看似好像挺简单的，
就是多创建几个定时器啊，我一开始也是这么想，然后一试在data里面写一个timer数组，里面存放不同的定时器，注
意异步问题，可以实现需求，但是会发现随着时间推移，页面越来越卡，才想起来要在组件消亡的时候去清除定时器，
然后根据思路就在消亡周期去清楚全部的定时器，可是出现了很奇怪的问题，我用遍历这个timer数组去清除全部的定
时器的时候没有清除掉，按理来说是可以清除掉的，一段时候后没弄出来，立刻寻找新的解决方案，关注到了$on、$once
这两个可以监听的事件，仔细一看 this.timer 唯一的作用只是为了能够在beforeDestroy 内取到计时器序号，除此之外没
有任何用处。没啥作用那我用$once在创建定时器的时候直接监听消亡钩子，执行清除这个定时器，这两步操作在一个函数中，
来替代原有的方案，使用这个方法后，即使我们同时创建多个计时器，也不影响效果。因为它们会在页面销毁后程序化的自
主清除，不会造成内存泄漏。
   这周安排的任务不是单人作战，除了前端部分，还需要和后端、测试一起开发任务，有一段时间没有和后端联调了，使用起来出现
了生疏，许多软件、流程都不太会了，所以趁着周末重新打开了我的毕设的后端，回顾后端从接口到数据库，细细的过
了一遍。
第七周
本周完成
1、完成小程序日历组件range模式
2、学习echarts
3、熟悉运营监控平台项目代码
下周安排
1、运营监控平台后端接入
2、完成小程序日历组件的时间选择功能
心得：
   这周写小程序日历组件的时候回头去看了上次写的代码，发现挺多问题的，所有的操作都耦合在一个函数里面，
不宜阅读，理解起来更加费劲，做了部分改造，把每一个小功能拆成一个函数，加上了备注，看起来舒服多了，但
是暴露出来了一些问题，比如打开这个组件的时候屏幕一闪一闪的，每次点击的时候也是这样，并且非常的卡。经过
分析是因为每一个小的功能都执行了setData，导致多次渲染视图，由于之前有一定的react的开发，我一直认为小程
序的setData的机制应该是和react里面的setData差不多渲染视图和数据赋值都是异步进行的，所以在每一个小的功能
里面都进行了setData，经过查阅小程序的文档，发现我大错特错，小程序的setData和react的setData是有不同的，
小程序的setData在渲染视图上面是异步的，但是在赋值方面是同步进行的，就是说在执行完setData的时候，直接
打印数据，数据已经改变了，根据这一特性稍微改动了我每一个小函数里面的setData操作，这边我不使用setData，
而是直接赋值操作，然后在最后进行一次统一的setData去渲染我的视图，发现可以了，闪屏的情况解决了，每一个
点击也流畅了。
第八周
本周完成：
1、完成组件库日历组件时间选择模式和日期时间一起选择模式
2、完成运营监控平台善自分部分接入
3、日历组件性能调优
下周安排：
1、日历组件性能调优
2、完成日历组件日期格式、默认时间等功能
3、编写日历组件说明文档
   这周在写组件库的时候发现一个问题，就是随着组件的不断打开关闭，这个组件所占用的内存会越来越多，并且无法
触发垃圾回收，会把一部分变量一次又一次的保存在内存中，导致组件越来越卡。经过排查排查发现是初始化的数据一直
不断被保存，每次打开显示组件的时候，里面的子组件加载的数据就会重新加载一遍，当组件移除的时候却并没有释放
点那部分初始数据，查阅资料并且做了很多demo实验发现这个问题不仅仅出现在我这个组件，每当页面切换，上一个
页面的初始化data一样会被保存，我猜想这个可能与小程序这门语言或者和开发工具有关，既然无法避免，我只能做到
让他尽量减少增加的速度，所以在每次移除组件的时候我会把数据清空，果然这个问题得到了缓解，经过暴力测试发现
问题不大，依然流畅。在查阅资料的时候学到了很多有关内存泄漏的知识，有一个点我以前没有关注到，刚好这个组件中
我也使用到了，就是eventBus这个帮助组件进行通信的类，它使用到了发布订阅的模式，当然他肯定是闭包导致，我们
在监控on的时候会把这个上下文的某个函数保存在eventBus的消息队列中，其实就是这个函数在这个上下文以外的地方
所引用了，然后就不能被自动回收了，我们通过组件消亡的时候去移除队列中的这个函数，就可以释放掉部分内存了。
第九周
本周完成：
1、运营监控平台bug修复、上线
2、完成日历组件第一个版本
下周安排：
1、运营监控平台bug修复
   这周在写组件文档的时候，因为组件文档和功能不太一样导致重新改功能，浪费了许多时间，才让我明白一定要先写
文档，把自己的思路和要实现的功能理顺畅再去下手，不然可能会做许多无用功。
   除此之外，遇到了一些有关事件循环的题目，做不了完全正确，就重新整理了有关事件循环，同步任务、异步任务、
异步代码的宏任务、微任务。执行顺序总结如下：
   先执行同步代码，遇到异步宏任务则将异步宏任务放入宏任务队列中，遇到异步微任务则将异步微任务放入微任务队列
中，当所有同步代码执行完毕后，再将异步微任务从队列中调入主线程执行，微任务执行完毕后再将异步宏任务从队列
中调入主线程执行，一直循环直至所有任务执行完毕。
   宏任务是主流，当js开始被执行的时候，就是开启一个宏任务，在宏任务中执行一条一条的指令；
宏任务可以同时有多个，但会按顺序一个一个执行；
   每一个宏任务，后面都可以跟一个微任务队列，如果微任务队列中有指令或方法，那么就会执行；如果没有，则开始执
行下一个宏任务，直到所有的宏任务执行完为止，微任务相当于宏任务的小尾巴；为什么有了宏任务，还会有微任务存
在？因为宏任务太占用性能，当需要一些较早就准备好的方法，排在最后才执行的时候，又不想新增一个宏任务，那么
就可以把这些方法，一个一个的放在微任务队列里面，在这个宏任务中的代码执行完后，就会执行微任务队列。
   因此当前同步代码执行，遇到异步任务，如果是异步宏任务，放入下一轮宏任务队列，是异步微任务，放入微任务队列
跟在当前宏任务屁股后面。微任务相当于宏任务的小尾巴，因此当前宏任务执行完，在它后面等着的异步微任务就会被
立刻放入队列继续执行。而异步的宏任务需要等到下一轮，从而造成了异步中微任务在宏任务之前执行的情况。
   在尝试不同事例的同时发现宏任务和微任务之间还要执行了页面渲染
第十周
本周完成：
1、运营监控平台维护
2、参加美美大同需求评审，熟悉其小程序和后台代码
3、完成taro的demo编写
下周安排
1、完成美美大同小程序评分模块和自处理模块
2、完成美美大同后台我爱大三模块
本周心得：
  这周主要的时间花在taro的学习上面，由于开发小程序的经验比较少加上比较薄弱react的开发经验使得在开发taro项目
花费的时间会偏长。但是taro的优势还是很明显的，针对不同的端去编写多套代码的成本显然非常高，使用taro写一套
代码就可以去自动编译为多套不同端的代码，针对我司缺点同样可见，针对组件方面，我们已经有一套初步原生的小程序
组件库，可以快速开发小程序，而是用taro代表着一切要重新再来，需要大家不断地去踩坑、填坑，也许初期项目开发
效率并不是很高，整体转型需要一段时间的过渡期。
   在写taro期间遇到了很多奇奇怪怪的问题，我们是使用react的函数式编程，taro3 跳转获取参数，在用到url传参给另一个
页面时，之前有过一些umi的开发经验，想都没想从另一个页面props能够解构出query，但是结果往往不是那么理想，taro
的props只是把整个url放进了props中，查阅了资料发现如果想直接拿到query有两种方法：
1、使用class组件的this.$router.params.
2、引用 taro 框架自带的
import Taro, {getCurrentInstance} from '@tarojs/taro' 
const  params = getCurrentInstance().router.params
  在使用本地图片的时候，使用src的相对引用，是完全错误的方式。本地图片只能使用模块的形式导入一般是两种方式improt require
import bottomListIv2 from '../../../res/image/example2.png'或者<Image src={require('../../../res/image/icon_look.png')}/>
然后我也仔细看了编译完后的代码，他是无法编译src/page以外的其他没有被引入的文件。所以在src中以相对引用的方式也就无法找
到相对应的文件，因为这个文件压根就不存在。
   
